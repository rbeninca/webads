<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>WebRTC com Supabase - Multi Peer (Debug)</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #chatLog { width: 100%; height: 200px; margin-top: 10px; }
    video { width: 500px; border: 1px solid #333; margin-top: 10px; }
    textarea, input, button { margin-top: 5px; }
  </style>
</head>
<body>
  <h2>WebRTC com Supabase - Multi Peer (Debug)</h2>

  <h3>Usu√°rios Dispon√≠veis</h3>
  <ul id="usuariosDisponiveis"></ul>

  <div>
    <h3>Chat</h3>
    <textarea id="chatLog" readonly></textarea><br>
    <input type="text" id="mensagem" placeholder="Digite uma mensagem">
    <button onclick="enviarMensagem()">Enviar Mensagem</button>
  </div>

  <h3>Compartilhar Tela</h3>
  <button onclick="compartilharTela()">Compartilhar Minha Tela</button>

  <h3>Tela Recebida</h3>
  <video id="remoteVideo" autoplay playsinline></video>

<script>
const SUPABASE_URL = 'https://heooobwioowbnnmkwlzt.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

let connection;
let dataChannel;
let screenStream;
let remoteStream;
let usuarioId = localStorage.getItem('usuarioId') || crypto.randomUUID();
localStorage.setItem('usuarioId', usuarioId);

// Estados para controle de conex√£o
let isCalling = false;
let isAnswering = false;

async function init() {
  await registrarUsuario();
  await ouvirUsuariosDisponiveis();
  await escutarOfertasRecebidas();
  console.log("‚úÖ Sistema inicializado e aguardando a√ß√µes do usu√°rio.");
}

async function registrarUsuario() {
  const { data: usuarioExistente } = await supabase
    .from('usuarios')
    .select('id')
    .eq('id', usuarioId)
    .single();

  if (!usuarioExistente) {
    await supabase.from('usuarios').insert([{ id: usuarioId, online: true }]);
    console.log('Usu√°rio criado:', usuarioId);
  } else {
    await supabase.from('usuarios').update({ online: true }).eq('id', usuarioId);
    console.log('Usu√°rio existente atualizado:', usuarioId);
  }
}

async function ouvirUsuariosDisponiveis() {
  atualizarListaUsuarios();

  supabase.channel('usuarios')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'usuarios' }, payload => {
      console.log('Altera√ß√£o em usuarios:', payload);
      atualizarListaUsuarios();
    })
    .subscribe();
}

async function atualizarListaUsuarios() {
  const { data } = await supabase.from('usuarios').select('*').neq('id', usuarioId);
  const lista = document.getElementById('usuariosDisponiveis');
  lista.innerHTML = '';

  if (!data || data.length === 0) {
    console.warn('Nenhum usu√°rio dispon√≠vel encontrado!');
  }

  data.forEach(usuario => {
    const li = document.createElement('li');
    li.textContent = `Usu√°rio: ${usuario.id}`;
    const btn = document.createElement('button');
    btn.textContent = 'Conectar';
    btn.onclick = () => iniciarChamada(usuario.id);
    li.appendChild(btn);
    lista.appendChild(li);
  });
}

async function iniciarChamada(destinoId) {
  if (isCalling || isAnswering) {
    console.warn('J√° em uma chamada ativa. Ignorando nova tentativa.');
    return;
  }

  console.log('üîî Iniciando chamada para:', destinoId);
  isCalling = true;

  connection = createPeerConnection(destinoId);
  dataChannel = connection.createDataChannel('chat');
  setupDataChannel();

  const offer = await connection.createOffer();
  await connection.setLocalDescription(offer);

  console.log('üì® Offer criada e enviada para:', destinoId);

  await supabase.from('sinalizacao').upsert([{ origem: usuarioId, destino: destinoId, offer: connection.localDescription }]);

  listenForAnswer(destinoId);
  listenForIceCandidates(destinoId, 'origem');
}

async function escutarOfertasRecebidas() {
  console.log('üïë Escutando ofertas para:', usuarioId);

  supabase.channel('sinalizacao')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'sinalizacao', filter: `destino=eq.${usuarioId}` }, async payload => {
      const { offer, origem } = payload.new;

      if (!offer) {
        console.warn('‚ö†Ô∏è Oferta n√£o encontrada no payload:', payload);
        return;
      }

      if (isCalling || isAnswering) {
        console.warn('J√° em uma chamada ativa. Ignorando oferta recebida.');
        return;
      }

      console.log('üì® Oferta recebida de:', origem);
      isAnswering = true;

      connection = createPeerConnection(origem);
      await connection.setRemoteDescription(new RTCSessionDescription(offer));
      console.log('‚úÖ Offer aplicada. Criando answer...');

      const answer = await connection.createAnswer();
      await connection.setLocalDescription(answer);
      console.log('üì§ Answer criada e enviada para:', origem);

      await supabase.from('sinalizacao').update({ answer: connection.localDescription }).eq('origem', origem).eq('destino', usuarioId);

      listenForIceCandidates(origem, 'destino');
    })
    .subscribe();
}

async function listenForAnswer(destinoId) {
  console.log('üïë Aguardando resposta (answer) de:', destinoId);
  supabase.channel('sinalizacao')
    .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'sinalizacao', filter: `origem=eq.${usuarioId}` }, async payload => {
      const answer = payload.new.answer;
      if (answer) {
        console.log('üì• Answer recebida! Aplicando...');
        await connection.setRemoteDescription(new RTCSessionDescription(answer));
        console.log('‚úÖ Answer aplicada com sucesso.');
      } else {
        console.warn('‚ö†Ô∏è Answer vazia no payload:', payload);
      }
    })
    .subscribe();
}

async function listenForIceCandidates(remoteId, role) {
  const sala = role === 'origem' ? `${usuarioId}_${remoteId}` : `${remoteId}_${usuarioId}`;

  console.log(`üïë Escutando ICE candidates para sala ${sala}`);

  supabase.channel('candidatos')
    .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'candidatos', filter: `sala=eq.${sala}` }, payload => {
      const candidate = payload.new.candidate;
      console.log('üì• ICE candidate recebido:', candidate);

      if (candidate) {
        connection.addIceCandidate(new RTCIceCandidate(candidate));
        console.log('‚úÖ ICE candidate adicionado na conex√£o');
      }
    })
    .subscribe();
}

function createPeerConnection(remoteId) {
  console.log('üîß Criando peer connection com:', remoteId);

  const pc = new RTCPeerConnection();
  remoteStream = new MediaStream();
  document.getElementById('remoteVideo').srcObject = remoteStream;

  pc.onicecandidate = event => {
    if (event.candidate) {
      const sala = `${usuarioId}_${remoteId}`;
      console.log('üì§ Enviando ICE candidate', event.candidate);
      supabase.from('candidatos').insert([{ sala, role: 'origem', candidate: event.candidate }]);
    }
  };

  pc.ontrack = event => {
    console.log('üé• Track recebida:', event.track);
    remoteStream.addTrack(event.track);
  };

  pc.oniceconnectionstatechange = () => {
    console.log('üîÑ ICE connection state:', pc.iceConnectionState);
  };

  pc.ondatachannel = event => {
    dataChannel = event.channel;
    setupDataChannel();
  };

  return pc;
}

function setupDataChannel() {
  dataChannel.onopen = () => console.log('‚úÖ Canal de dados aberto!');
  dataChannel.onmessage = event => {
    console.log('üì® Mensagem recebida:', event.data);
    log(`Mensagem recebida: ${event.data}`);
  };
}

function enviarMensagem() {
  const mensagem = document.getElementById('mensagem').value;
  if (dataChannel && dataChannel.readyState === 'open') {
    console.log('üì§ Enviando mensagem:', mensagem);
    dataChannel.send(mensagem);
    log(`Voc√™: ${mensagem}`);
  } else {
    alert('‚ùå Canal de dados n√£o est√° aberto.');
  }
}

async function compartilharTela() {
  try {
    screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
    screenStream.getTracks().forEach(track => connection.addTrack(track, screenStream));
    console.log('üñ•Ô∏è Compartilhando tela...');
  } catch (err) {
    console.error('‚ùå Erro ao compartilhar a tela:', err);
  }
}

function log(mensagem) {
  const chatLog = document.getElementById('chatLog');
  chatLog.value += mensagem + '\n';
  chatLog.scrollTop = chatLog.scrollHeight;
}

init();
</script>
</body>
</html>
